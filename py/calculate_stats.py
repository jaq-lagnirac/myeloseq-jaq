# Justin Caringal
# Reads in directory of VCF files and annotates inputted table with
# set/source of coverage

import os
import sys
import argparse
import logging
import pandas as pd

SEP = '\t'

EXIT = 'Exiting program.'
ROUNDING_DECIMALS = 5
VS_COV_CUTOFF = 50

# global vars


SCRIPT_PATH = os.path.abspath(__file__)
FORMAT = '[%(asctime)s] %(levelname)s %(message)s'
l = logging.getLogger()
lh = logging.StreamHandler()
lh.setFormatter(logging.Formatter(FORMAT))
l.addHandler(lh)
l.setLevel(logging.INFO)
debug = l.debug; info = l.info; warning = l.warning; error = l.error

DESCRIPTION = '''

Takes comparison table generated by coverage_table.py and a directory of VCF files to

annotated the table with the source (i.e. the "set") of the coverage

'''

EPILOG = '''

Outputs statistics in .err file.

'''

class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter,
    argparse.RawDescriptionHelpFormatter):
  pass
parser = argparse.ArgumentParser(description=DESCRIPTION, epilog=EPILOG,
  formatter_class=CustomFormatter)

parser.add_argument('coverage_table',
                    help='TSV table used to calculate statistics.')
parser.add_argument('-v', '--verbose',
                    action='store_true',
                    help='Set logging level to DEBUG')

args = parser.parse_args()

if args.verbose:
  l.setLevel(logging.DEBUG)


# sets up fields for extraction dictionary
recognized_sets = ['dragen',
                   'pindel',
                   'dragen-pindel']
# adds misc, which is separate from the recognized sets calculated
total_sets = recognized_sets
total_sets.append('misc')
# sets up global extraction dictionaries
rel_diff_dict = {}
vs_cov_dict = {}
for set_type in total_sets:
  rel_diff_dict[set_type] = []
  vs_cov_dict[set_type] = []

# extracts data, stores in global dict
def extract_data(row):
  # connects global dicts
  global rel_diff_dict
  global vs_cov_dict

  # extracts data from row
  set_source = row['set']
  rel_diff = row['relative difference']
  vs_cov = row['json vs bed coverage']

  # handles misc sets, exits function safely
  if set_source not in recognized_sets:
    rel_diff_dict['misc'].append(rel_diff)
    vs_cov_dict['misc'].append(vs_cov)
    return # exits function, leaves unchanged
  
  rel_diff_dict[set_source].append(rel_diff)
  vs_cov_dict[set_source].append(vs_cov)
  return # exits function, leaves unchanged


def avg(input_list):
  return sum(input_list) / len(input_list)


debug('%s begin', SCRIPT_PATH)


# read in table
info(f'Reading table: {args.coverage_table}')
df = pd.read_csv(args.coverage_table, sep=SEP)

df.apply(extract_data, axis=1)

debug(f'VERSUS COVERAGE CUTOFF: {VS_COV_CUTOFF}')

for set_type in total_sets:
  
  # prints header to err file
  set_str = f'STATISTICS - {set_type.upper()}' # formats string for output
  info(f'--------------------{set_str:^30}--------------------')

  # extracts lists from dicts
  rel_diff_list = rel_diff_dict[set_type]
  vs_cov_list = vs_cov_dict[set_type]

  # attempts average, will iterate to next set if empty
  try:
    avg_rel_diff = round(avg(rel_diff_list), ROUNDING_DECIMALS)
    avg_vs_cov = round(avg(vs_cov_list), ROUNDING_DECIMALS)
  except:
    info(f'No values exist for {set_type}.')
    continue

  info(f'Total Extractions: {len(rel_diff_list)}')
  info(f'Average Relative Difference: {avg_rel_diff}')
  info(f'Average Difference in Coverage: {avg_vs_cov}')

  # if x is greater than cutoff, add to list
  greater_list = [x for x in vs_cov_list if abs(x) > VS_COV_CUTOFF]
  less_list = [x for x in vs_cov_list if abs(x) <= VS_COV_CUTOFF]
  info(f'Absolute differences greater than {VS_COV_CUTOFF}: {len(greater_list)} ' \
       f'({len(less_list)} less than or equal to cutoff)')

  greater_values = str(greater_list).replace('[', '').replace(']', '')
  less_values = str(less_list).replace('[', '').replace(']', '')
  debug(f'Absolute values greater than {VS_COV_CUTOFF}: {greater_values}')
  debug(f'Absolute values less than or equal to {VS_COV_CUTOFF}: {less_values}')



debug('%s end', SCRIPT_PATH)